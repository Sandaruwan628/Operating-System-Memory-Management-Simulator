# OS Memory Management Simulator (Java)

A didactic simulator of virtual-to-physical address translation featuring **Cache**, **TLB**, **Page Table**, and **Main Memory**. It prints a step-by-step trace (hits/misses, addresses, and the retrieved data).

> **Note:** The original class is named `MemoryMangement` (typo kept intentionally to match the provided code). You may keep it as-is or refactor consistently.

---

## 🧭 Overview

flowchart LR
    CPU[CPU makes virtual address] --> C[Cache Lookup]
    C -- miss --> T[TLB Lookup]
    C -- hit --> PAB[Physical Base]
    T -- miss --> PT[Page Table Lookup]
    T -- hit --> PAB
    PT --> PAB
    PAB --> M[Main Memory Read (base ⊕ offset)]
~~~

**What it demonstrates**
- Logical (virtual) address generation and split into **pageNumber** and **offset** (1 digit).
- **Cache → TLB → Page Table** lookup chain with hit/miss trace.
- Physical base + offset (string-concatenated for teaching simplicity).
- Retrieving the final value from **main memory**.

---


---

## ⚙️ How It Works (Quick Flow)

1. **Allocate memory**: Fills `mainMemory` with `memorySize = pageTableSize * 1000` random integers.
2. **Generate virtual address**:
   - Random `virtualAddress ∈ [0, pageTableSize)`.
   - **offset** = last digit; **pageNumber** = remaining digits.
3. **Lookup path**:
   - **Cache** by `pageNumber` → hit: get `physicalBase`; miss: check TLB.
   - **TLB** → hit: `physicalBase`; miss: check Page Table.
   - **Page Table** → returns `physicalBase` and updates TLB.
4. **Main memory**:
   - Build final index by string-concatenating `physicalBase` and the single-digit `offset`.
   - Return the stored integer and print the trace.

---

## 🔢 Key Parameters (defaults)

- `pageTableSize = 10_000`  
- `memorySize = pageTableSize * 1000` → **10,000,000** ints
- `tlb = new int[200][2]`, `cache = new int[10][2]`
- Page table maps `page i → frameBase = i * 100` (stride 100)

> **RAM note:** 10M `int`s plus arrays & JVM overhead can use a few hundred MB. Reduce `pageTableSize` if your machine is tight on memory.

---

## 🚀 Getting Started

### Prerequisites
- Java 8+ (OpenJDK 8/11/17 tested)
- ~0.3–1.0 GB free RAM (for default sizes)

### Build & Run

~~~bash
# Compile
javac Main.java

# Run (optionally raise heap if needed)
java -Xmx1g Main
~~~

> If you renamed the class to `MemoryManagement` or changed the filename:
> - Ensure the public class matches the filename.
> - Recompile and run accordingly.

---

## 🖨️ Example Output (abridged)

~~~text
Memory size allocated as: 10000000

Allocating Memory spaces...
All memory spaces are allocated succesfully!

Generating Logical address...

Logical address generated by the CPU: 1234
Offset of the address: 4

Loading Cache...
Cache loaded!

Loading TLB...
TLB loaded!

Creating page table...

Loading memory locations to page table...
Page Table Created! 

Searching the Physical Address...

Searching in Cache...
Cache miss!

Searching in TLB...
TLB miss!

Searching in Page Table...
Page Table Hit! 

Table Index: 123
Physical Address found as: 12300

Searching Main memory...
Address conversion running...
Retreiving data...

The main memory location: 123004
Stored data: 987654321
~~~

(Exact numbers vary per run.)

---

## 🧠 Assumptions (for teaching clarity)

- **Offset width = 1 digit** (`0..9`).
- Frame base increases by `100` per page; final index = `"base" + "offset"` (string concat).
- Cache & TLB are simple arrays with **linear search** (no associativity / replacement policy).
- All pages are resident (no page faults / disk I/O).
- Read-only demo (no writes).

---

## ⚠️ Known Limitations & Quirks

- **Single-digit address edge case**: If the random virtual address is a single digit, `pageNumber` parsing from an empty string can throw `NumberFormatException`.  
  **Quick fix idea** (inside `generateLogicalAddress()`):

  ~~~java
  if (address.length() == 1) {
      this.pageNumber = 0;
      this.offSet = Integer.parseInt(address);
      System.out.println("Logical address generated by the CPU: " + address);
      System.out.println("Offset of the address: " + this.offSet + "\n");
      return 0;
  }
  // ...continue with current logic for length > 1
  ~~~

- **Cache/TLB updates**: `updateCache` / `updateTLB` currently overwrite **all** slots with the same `(page, base)`—useful for demo but unrealistic.
- **String-based address composition** is intentionally non-realistic.
- **Large memory footprint**: Reduce `pageTableSize` if you hit OOM.

---

## 📊 Complexity

- Cache lookup: `O(C)` (C=10 by default)  
- TLB lookup: `O(T)` (T=200)  
- Page table: direct index `O(1)`  
- Main memory read: `O(1)`

---

## 🛤️ Roadmap / Ideas

- Implement **LRU/FIFO** replacement for Cache & TLB.
- Use **bit masks** for page/offset with configurable sizes.
- Add **stats**: hit/miss counters, AMAT, multiple trials.
- Add **CLI args** for sizes, seeds, and run counts.
- Simulate **page faults** and simple replacement in main memory.
- Add **unit tests** for address split/compose.

---

## 🤝 Contributing

PRs welcome—especially for:
- Fixing the single-digit edge case
- Realistic replacement policies
- Configurable address widths & statistics

---

## 📝 License

MIT — free to use for education and demos.
